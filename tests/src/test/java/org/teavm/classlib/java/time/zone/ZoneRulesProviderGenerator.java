/*
 *  Copyright 2020 Joerg Hohwiller.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.teavm.classlib.java.time.zone;

import java.io.BufferedWriter;
import java.lang.reflect.Field;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.DayOfWeek;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.zone.ZoneOffsetTransitionRule;
import java.time.zone.ZoneRules;
import java.time.zone.ZoneRulesProvider;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Code-Generator for hardcoded TZDB.
 */
public class ZoneRulesProviderGenerator {

    private static final String HEADER = "/*\n" //
            + " *  Copyright 2020 generated by Joerg Hohwiller.\n" //
            + " *\n" //
            + " *  Licensed under the Apache License, Version 2.0 (the \"License\");\n" //
            + " *  you may not use this file except in compliance with the License.\n" //
            + " *  You may obtain a copy of the License at\n" //
            + " *\n" //
            + " *       http://www.apache.org/licenses/LICENSE-2.0\n" //
            + " *\n" //
            + " *  Unless required by applicable law or agreed to in writing, software\n" //
            + " *  distributed under the License is distributed on an \"AS IS\" BASIS,\n" //
            + " *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" //
            + " *  See the License for the specific language governing permissions and\n" //
            + " *  limitations under the License.\n" //
            + " */\n";

    private static final Field STANDARD_TRANSITIONS;

    private static final Field STANDARD_OFFSETS;

    private static final Field SAVINGS_INSTANT_TRANSITIONS;

    private static final Field WALL_OFFSETS;

    private static final Field LAST_RULES;
    static {
        try {
            STANDARD_TRANSITIONS = ZoneRules.class.getDeclaredField("standardTransitions");
            STANDARD_TRANSITIONS.setAccessible(true);
            STANDARD_OFFSETS = ZoneRules.class.getDeclaredField("standardOffsets");
            STANDARD_OFFSETS.setAccessible(true);
            SAVINGS_INSTANT_TRANSITIONS = ZoneRules.class.getDeclaredField("savingsInstantTransitions");
            SAVINGS_INSTANT_TRANSITIONS.setAccessible(true);
            WALL_OFFSETS = ZoneRules.class.getDeclaredField("wallOffsets");
            WALL_OFFSETS.setAccessible(true);
            LAST_RULES = ZoneRules.class.getDeclaredField("lastRules");
            LAST_RULES.setAccessible(true);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) throws Exception {

        Map<String, List<String>> zoneMap = createZoneMap();
        for (String group : zoneMap.keySet()) {
            List<String> zoneIds = zoneMap.get(group);
            Collections.sort(zoneIds);
            Path path = Paths.get("src/main/java/org/teavm/classlib/java/time/zone", "TTzdbInternal" + group + ".java");
            try (BufferedWriter writer = Files.newBufferedWriter(path)) {
                generateZoneIds(writer, group, zoneIds);
            }
        }
    }

    private static void generateZoneIds(BufferedWriter writer, String group, List<String> zoneIds) throws Exception {

        writer.write(HEADER);
        writer.write("package org.teavm.classlib.java.time.zone;\n");
        writer.write("\n");
        writer.write("import java.util.Map;\n");
        writer.write("import java.time.zone.ZoneOffsetTransitionRule.TimeDefinition;\n");
        writer.write("\n");
        writer.write("final class TTzdbInternal");
        writer.write(group);
        writer.write(" {\n");
        writer.write("    static void init(Map<String, ZoneRules> map) {\n");

        int count = 0;
        int init = 0;
        for (String zoneId : zoneIds) {
            count++;
            writer.write("        map.put(\"");
            writer.write(zoneId);
            writer.write("\", new TStandardZoneRules(new long[] {");
            ZoneId zone = ZoneId.of(zoneId);
            ZoneRules rules = zone.getRules();
            long[] standardTransitions = (long[]) STANDARD_TRANSITIONS.get(rules);
            String prefix = "";
            for (long stdTr : standardTransitions) {
                writer.write(prefix);
                prefix = ", ";
                writer.write(Long.toString(stdTr));
                writer.write("L");
            }
            writer.write("}, new int[] {");
            ZoneOffset[] standardOffsets = (ZoneOffset[]) STANDARD_OFFSETS.get(rules);
            prefix = "";
            for (ZoneOffset stdOff : standardOffsets) {
                writer.write(prefix);
                prefix = ", ";
                writer.write(Integer.toString(stdOff.getTotalSeconds()));
            }
            writer.write("}, new long[] {");
            long[] savingsInstantTransitions = (long[]) SAVINGS_INSTANT_TRANSITIONS.get(rules);
            prefix = "";
            for (long savTr : savingsInstantTransitions) {
                writer.write(prefix);
                prefix = ", ";
                writer.write(Long.toString(savTr));
                writer.write("L");
            }
            writer.write("}, new int[] {");
            ZoneOffset[] wallOffsets = (ZoneOffset[]) WALL_OFFSETS.get(rules);
            prefix = "";
            for (ZoneOffset wallOff : wallOffsets) {
                writer.write(prefix);
                prefix = ", ";
                writer.write(Integer.toString(wallOff.getTotalSeconds()));
            }
            writer.write("}");
            ZoneOffsetTransitionRule[] lastRules = (ZoneOffsetTransitionRule[]) LAST_RULES.get(rules);
            if ((lastRules == null) || (lastRules.length == 0)) {
            } else {
                for (ZoneOffsetTransitionRule rule : lastRules) {
                    writer.write(", new ZoneOffsetTransitionRule(");
                    writer.write(Integer.toString(rule.getMonth().getValue()));
                    writer.write(",");
                    writer.write(Integer.toString(rule.getDayOfMonthIndicator()));
                    writer.write(",");
                    DayOfWeek dayOfWeek = rule.getDayOfWeek();
                    if (dayOfWeek == null) {
                        writer.write("null");
                    } else {
                        writer.write(Integer.toString(dayOfWeek.getValue()));
                    }
                    writer.write(",");
                    long secondsOfDay = rule.getLocalTime().getLong(java.time.temporal.ChronoField.SECOND_OF_DAY);
                    writer.write(Long.toString(secondsOfDay));
                    writer.write(",");
                    writer.write(rule.isMidnightEndOfDay() ? "1" : "0");
                    writer.write(",");
                    writer.write(Integer.toString(rule.getTimeDefinition().ordinal()));
                    writer.write(",");
                    writer.write(Integer.toString(rule.getStandardOffset().getTotalSeconds()));
                    writer.write(",");
                    writer.write(Integer.toString(rule.getOffsetBefore().getTotalSeconds()));
                    writer.write(",");
                    writer.write(Integer.toString(rule.getOffsetAfter().getTotalSeconds()));
                    writer.write(")");
                }
            }
            writer.write("));\n");
            if (count == 50) {
                count = 0;
                init++;
                writer.write("        init" + init + "(map);\n");
                writer.write("    }\n");
                writer.write("\n");
                writer.write("    private static void init" + init + "(Map<String, ZoneRules> map) {\n");
            }

        }
        writer.write("    }\n");
        writer.write("}\n");
    }

    private static Map<String, List<String>> createZoneMap() {

        Map<String, List<String>> zoneMap = new HashMap<>();
        for (String zoneId : ZoneRulesProvider.getAvailableZoneIds()) {
            String group;
            int groupIndex = zoneId.indexOf('/');
            if (groupIndex > 0) {
                group = zoneId.substring(0, groupIndex);
            } else {
                group = "Misc";
            }
            if ("Arctic".equals(group) || "Chile".equals(group) || "Brazil".equals(group) || "Mexico".equals(group)) {
                group = "Misc";
            }
            List<String> list = zoneMap.get(group);
            if (list == null) {
                list = new ArrayList<>();
                zoneMap.put(group, list);
            }
            list.add(zoneId);
        }
        return zoneMap;
    }

}
